<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - minimap</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		a {
			color: #08f;
		}

		b {
			color: lightgreen;
		}
	</style>
</head>

<body>
	<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - minimap<br />
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import Stats from '../examples/jsm/libs/stats.module.js';

		var SCREEN_WIDTH = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;
		var aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

		var container, stats;
		var camera, scene, renderer, mesh;
		var mainCamera, minimapCamera;
		var mainCameraHelper, minimapCameraHelper;
		var lookat = new THREE.Vector3(), lastLookat = new THREE.Vector3();
		var fov = 60;
		var frustumSize = 1000;
		var mapSize = 300;

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			scene = new THREE.Scene();

			mainCamera = new THREE.PerspectiveCamera(fov, aspect, 0.01, 10000);
			getLookatVecProjected(mainCamera, lastLookat);
			mainCameraHelper = new THREE.CameraHelper(mainCamera);
			scene.add(mainCameraHelper);

			//
			minimapCamera = new THREE.OrthographicCamera(
				-frustumSize / 2,
				frustumSize / 2,
				frustumSize / 2,
				-frustumSize / 2,
				0.01,
				10000);
			// set orthographic camera always look downward
			minimapCamera.lookAt(new THREE.Vector3(0, -1, 0));

			minimapCameraHelper = new THREE.CameraHelper(minimapCamera);
			scene.add(minimapCameraHelper);

			//
			initMeshes();

			initBackplane(0x000000);

			initIndicator();

			//
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.autoClear = false;
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			container.appendChild(renderer.domElement);

			//
			stats = new Stats();
			container.appendChild(stats.dom);

			//
			window.addEventListener('resize', onWindowResize, false);
		}

		//
		function getLookatVecProjected(object, result) {
			object.getWorldDirection(result);
			result.projectOnPlane(new THREE.Vector3(0, -1, 0)); // get the lookat vector projected on the orthographic camera
		}

		//
		function initMeshes() {
			mesh = new THREE.Mesh(
				new THREE.SphereBufferGeometry(100, 32, 8),
				new THREE.MeshBasicMaterial({ color: 0xff0000 })
			);
			scene.add(mesh);

			var mesh2 = new THREE.Mesh(
				new THREE.SphereBufferGeometry(50, 32, 8),
				new THREE.MeshBasicMaterial({ color: 0x00ff00 })
			);
			mesh2.position.y = 150;
			mesh.add(mesh2);

			var mesh3 = new THREE.Mesh(
				new THREE.SphereBufferGeometry(20, 32, 8),
				new THREE.MeshBasicMaterial({ color: 0x0000ff })
			);
			mesh3.position.z = 150;
			mesh.add(mesh3);

			var plane = new THREE.Mesh(
				new THREE.BoxBufferGeometry(200, 1, 200),
				new THREE.MeshBasicMaterial({ color: 0x00ffff })
			);
			plane.position.y = 100;
			plane.position.z = -200;
			scene.add(plane);
		}

		//
		function initBackplane(color) {
			var width = Math.abs(minimapCamera.left - minimapCamera.right);
			var height = Math.abs(minimapCamera.top - minimapCamera.bottom);
			var plane = new THREE.Mesh(
				new THREE.PlaneBufferGeometry(width, height, 1),
				new THREE.MeshBasicMaterial({ color: color, side: THREE.FrontSide })
			);
			plane.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), - Math.PI / 2);
			scene.add(plane);
			minimapCamera.backplane = plane;
		}

		//
		function initIndicator() {
			var sector = new THREE.Mesh(
				new THREE.RingBufferGeometry(mapSize, 1, 10, 1, (0.5 - fov / 180) * Math.PI, fov / 90 * Math.PI),
				new THREE.MeshBasicMaterial({ color: 0xff00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.3 })
			);
			sector.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
			var sectorLookat = new THREE.Vector3();
			getLookatVecProjected(sector, sectorLookat);
			sector.rotateZ(lastLookat.angleTo(sectorLookat)); // set the sector indicator rotation the same with mainCamera lookat
			scene.add(sector);

			var dot = new THREE.Mesh(
				new THREE.CircleBufferGeometry(mapSize / 15, 16, 0, 2 * Math.PI),
				new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
			);
			dot.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
			scene.add(dot);

			minimapCamera.indicator = {
				dot: dot,
				sector: sector,
				setVisible: function (flag) {
					this.dot.visible = flag;
					this.sector.visible = flag;
				}
			};
		}

		//
		function updateMinimapCamera() {
			minimapCamera.position.set(mainCamera.position.x, mainCamera.position.y - 10, mainCamera.position.z);
			minimapCamera.updateMatrixWorld();
			minimapCamera.backplane.position.set(mainCamera.position.x, mainCamera.position.y - minimapCamera.far, mainCamera.position.z);

			var idc = minimapCamera.indicator;
			idc.sector.position.set(minimapCamera.position.x, minimapCamera.position.y - 1, minimapCamera.position.z);
			idc.dot.position.set(minimapCamera.position.x, minimapCamera.position.y - 1, minimapCamera.position.z);

			getLookatVecProjected(mainCamera, lookat);

			var angle = lookat.angleTo(lastLookat);
			idc.sector.rotateZ(angle); // rotate the indicator to the direction of mainCamera
			idc.sector.updateMatrixWorld();

			getLookatVecProjected(mainCamera, lastLookat); // store the last lookat vector
		}

		//
		function onWindowResize() {

			SCREEN_WIDTH = window.innerWidth;
			SCREEN_HEIGHT = window.innerHeight;
			aspect = SCREEN_WIDTH / SCREEN_HEIGHT;

			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			camera.aspect = 0.5 * aspect;
			camera.updateProjectionMatrix();

			mainCamera.aspect = 0.5 * aspect;
			mainCamera.updateProjectionMatrix();

			minimapCamera.left = - 0.5 * frustumSize * aspect / 2;
			minimapCamera.right = 0.5 * frustumSize * aspect / 2;
			minimapCamera.top = frustumSize / 2;
			minimapCamera.bottom = - frustumSize / 2;
			minimapCamera.updateProjectionMatrix();

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			render();
			stats.update();

		}


		function render() {

			var r = 0;
			var r = Date.now() * 0.0005;

			mainCamera.position.x = 200 * Math.cos(r);
			mainCamera.position.z = 200 * Math.sin(r);
			mainCamera.position.y = Math.abs(300 * Math.cos(r));


			// set perspective camera lookAt
			mainCamera.lookAt(mesh.position);
			mainCamera.updateMatrixWorld();

			// set orthographic camera position to be certain height above perspective camera
			updateMinimapCamera();

			renderer.clear();

			// render perspective (main) camera
			minimapCamera.backplane.visible = false;
			minimapCamera.indicator.setVisible(false);
			minimapCameraHelper.visible = false;
			mainCameraHelper.visible = false;
			renderer.setViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
			renderer.setScissor(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
			// var a = new THREE.Vector4();
			// renderer.getCurrentViewport(a);
			// console.log(SCREEN_WIDTH, SCREEN_HEIGHT, a);
			renderer.setScissorTest(true);
			renderer.setClearColor(new THREE.Color(0x666666));
			renderer.render(scene, mainCamera);


			// render orthographic (minimap) camera
			minimapCamera.backplane.visible = true;
			minimapCamera.indicator.setVisible(true);
			minimapCameraHelper.visible = false;
			mainCameraHelper.visible = false;
			renderer.setViewport(0, 0, mapSize, mapSize);
			renderer.render(scene, minimapCamera);

		}


		window.mainCamera = mainCamera;
		window.minimapCamera = minimapCamera;


	</script>

</body>

</html>