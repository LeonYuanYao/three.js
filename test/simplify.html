<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - Geometry Simplify</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>

<body>
	<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Simplify
		<input type="button" id="export" value="ExportOBJ" />
		<input type="button" id="linevisible" value="Lines" />
		<input type="button" id="simplify" value="Simplify" />
		<input type="number" id="errorThreshold" style="width: 50px;" value=1.0 />
		<input type="number" id="segments" style="width: 50px;" value=5 />
		<a id="faceCount"></a>
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { DDSLoader } from '../examples/jsm/loaders/DDSLoader.js';
		import { MTLLoader } from '../examples/jsm/loaders/MTLLoader.js';
		import { OBJLoader } from '../examples/jsm/loaders/OBJLoader.js';
		import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';
		import { OBJExporter } from '../examples/jsm/exporters/OBJExporter.js';
		import { TeapotBufferGeometry } from '../examples/jsm/geometries/TeapotBufferGeometry.js';
		import { DefaultSimplifier, QuadricSimplifier } from '../node_bin_yy/GeometrySimplifier.js';

		var container;

		var camera, scene, renderer, controls, group, sceneBox, line;

		var mouseX = 0, mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var linevisible = true;

		var defaultSimplifier = new DefaultSimplifier();
		var quadricSimplifier = new QuadricSimplifier();

		init();
		animate();


		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 200000);
			camera.up.set(0, 0, 1);

			// scene
			scene = new THREE.Scene();

			var ambientLight = new THREE.AmbientLight(0xcccccc, 0.6);
			scene.add(ambientLight);

			var pointLight = new THREE.PointLight(0xffffff, 0.8);
			camera.add(pointLight);
			scene.add(camera);

			var axesHelper = new THREE.AxesHelper(500);
			scene.add(axesHelper);

			group = new THREE.Group();
			sceneBox = new THREE.Box3();

			// init model
			var grids = 5;
			var length = 10;

			// for (let i = 0; i < grids; i++) {
			// 	for (let j = 0; j < grids; j++) {
			// 		var geometry = new THREE.BoxGeometry(length, length, length);
			// 		var material = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, flatShading: true });
			// 		var mesh = new THREE.Mesh(geometry, material);
			// 		mesh.position.set(i * length * 1.1, j * length * 1.1, 0);
			// 		mesh.updateMatrixWorld();
			// 		geometry.computeBoundingBox();
			// 		sceneBox.union(geometry.boundingBox.clone().applyMatrix4(mesh.matrix));
			// 		group.add(mesh);
			// 	}
			// }


			// model
			var geometry = new THREE.IcosahedronBufferGeometry(length * 2, 2);
			// var geometry = new THREE.BoxBufferGeometry( length * 2, length * 2, length * 2, 6, 6, 6 );
			// var geometry = new THREE.CylinderBufferGeometry(length * 2, length * 2, length * 2, 32);
			// var geometry = new THREE.IcosahedronGeometry(length * 2, 3);
			// var geometry = new TeapotBufferGeometry(400, 15, true, true, true, true, true);


			// var material = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, flatShading: false });
			var material = new THREE.MeshPhongMaterial({ color: 0x156289, flatShading: false });
			var texture = new THREE.TextureLoader().load("../examples/textures/uv_grid_opengl.jpg");
			// material.map = texture;
			var mesh = new THREE.Mesh(geometry, material);
			geometry.computeBoundingBox();
			sceneBox.union(geometry.boundingBox.clone().applyMatrix4(mesh.matrix));
			console.log(sceneBox)
			group.add(mesh);

			var wireframe = new THREE.WireframeGeometry(geometry);
			line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0xffffff }));
			line.scale.set(1.0001, 1.0001, 1.0001);
			group.add(line);


			// obj model
			new MTLLoader()
				.setPath('./models/')
				.load('1.mtl', function (materials) {

					materials.preload();

					new OBJLoader()
						.setMaterials(materials)
						.setPath('./models/')
						.load('rail.obj', function (obj) {
							mesh = obj.children[0];
							geometry = mesh.geometry;

							if (mesh.material.color.r == 1 && mesh.material.color.g == 1 && mesh.material.color.b == 1)
								mesh.material = material;

							if (mesh.material.bumpMap){
								// mesh.material.bumpScale = 0.5;
								var texture = mesh.material.bumpMap;
								mesh.material.normalMap = texture;
								mesh.material.bumpMap = null;
							}

							group.children[0] = mesh;

							wireframe = new THREE.WireframeGeometry(mesh.geometry);
							line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0xffffff }));

							line.scale.set(1.001, 1.001, 1.001);
							group.children[1] = line;

							geometry.computeBoundingBox();
							console.log("size", geometry.boundingBox.getSize())
							sceneBox = geometry.boundingBox;
							camera.position.set(sceneBox.getSize().x * 2, sceneBox.getSize().y * 2, sceneBox.getSize().z * 2);
							camera.lookAt(sceneBox.getCenter(new THREE.Vector3()));

						});

				});



			// simplify geometry
			var simplifyBtn = document.getElementById("simplify");
			simplifyBtn.onclick = function () {
				var segments = parseInt(document.getElementById("segments").value);
				var errorThreshold = document.getElementById("errorThreshold").value;
				var t1 = performance.now();
				var newGeom = defaultSimplifier.simplify(geometry, {
					// segments: segments,
					errorThreshold: errorThreshold, 
					normalJoinAngle: 75, 
					recomputeNormal: false
				});
				// var newGeom2 = quadricSimplifier.simplify(geometry, {});
				
				console.log("timeDiff", performance.now() - t1);
				console.log(newGeom.faces.length);
				document.getElementById("faceCount").innerText = newGeom.faces.length;

				wireframe = new THREE.WireframeGeometry(newGeom);
				line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0xffffff }));
				line.scale.set(1.0001, 1.0001, 1.0001);

				// mesh = new THREE.Mesh(newGeom, material);
				mesh.geometry = new THREE.BufferGeometry().fromGeometry(newGeom);
				group.children[0] = mesh;
				group.children[1] = line;
				sceneBox = new THREE.Box3();
				sceneBox.union(newGeom.boundingBox.clone().applyMatrix4(mesh.matrix));
			}

			//

			// Export button function
			var exportBtn = document.getElementById("export");
			exportBtn.onclick = function () {
				if (mesh.material instanceof Array) {
					mesh.material.forEach((mat, i) => mat.name = i.toString());
				}
				var exporter = new OBJExporter();
				var result = exporter.parse(mesh);
				// result = result.replace(/o \n/g, '');

				var MIME_TYPE = 'text/plain';
				window.URL = window.webkitURL || window.URL;

				var blob = new Blob([result], { type: MIME_TYPE });
				var a = document.createElement('a');
				a.download = 'export.obj';
				a.href = window.URL.createObjectURL(blob);
				a.textContent = 'Download ready';
				a.dataset.downloadurl = [MIME_TYPE, a.download, a.href].join(':');
				a.click();
			}


			//

			var lineVisBtn = document.getElementById("linevisible");
			lineVisBtn.onclick = function () {
				linevisible = !linevisible;
			}

			//

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			scene.add(group);

			var size = new THREE.Vector3();
			sceneBox.getSize(size);
			var diameter = Math.max(size.x, size.y, size.z);
			camera.position.set(diameter, diameter, diameter);
			camera.lookAt(0, 0, 0);

			controls = new OrbitControls(camera, renderer.domElement);

			document.addEventListener('mousemove', onDocumentMouseMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onDocumentMouseMove(event) {

			mouseX = (event.clientX - windowHalfX) / 2;
			mouseY = (event.clientY - windowHalfY) / 2;

		}

		//

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			line.visible = linevisible;

			renderer.render(scene, camera);

		}

	</script>

</body>

</html>