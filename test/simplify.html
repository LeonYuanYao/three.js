<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - OBJLoader + MTLLoader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>

<body>
	<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Simplify
		<input type="button" id="export" value="ExportOBJ" />
		<input type="button" id="simplify" value="Simplify" />
		<input type="number" id="segments" style="width: 50px;" value=10 />
		<input type="button" id="grids" value="grids" />
	</div>

	<script type="module">

		import * as THREE from '../build/three.module.js';

		import { DDSLoader } from '../examples/jsm/loaders/DDSLoader.js';
		import { MTLLoader } from '../examples/jsm/loaders/MTLLoader.js';
		import { OBJLoader } from '../examples/jsm/loaders/OBJLoader.js';
		import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';
		import { OBJExporter } from '../examples/jsm/exporters/OBJExporter.js';
		import { GeometrySimplifyUtil } from './GeometrySimplifyUtil.js';

		var container;

		var camera, scene, renderer, controls, group, sceneBox;

		var mouseX = 0, mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;


		init();
		animate();


		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 200000);
			camera.up.set(0, 0, 1);

			// scene
			scene = new THREE.Scene();

			var ambientLight = new THREE.AmbientLight(0xcccccc, 0.6);
			scene.add(ambientLight);

			var pointLight = new THREE.PointLight(0xffffff, 0.8);
			camera.add(pointLight);
			scene.add(camera);

			var axesHelper = new THREE.AxesHelper(500);
			scene.add(axesHelper);

			group = new THREE.Group();
			sceneBox = new THREE.Box3();

			// init model
			var grids = 5;
			var length = 10;

			// for (let i = 0; i < grids; i++) {
			// 	for (let j = 0; j < grids; j++) {
			// 		var geometry = new THREE.BoxGeometry(length, length, length);
			// 		var material = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, flatShading: true });
			// 		var mesh = new THREE.Mesh(geometry, material);
			// 		mesh.position.set(i * length * 1.1, j * length * 1.1, 0);
			// 		mesh.updateMatrixWorld();
			// 		geometry.computeBoundingBox();
			// 		sceneBox.union(geometry.boundingBox.clone().applyMatrix4(mesh.matrix));
			// 		group.add(mesh);
			// 	}
			// }



			// model
			var geometry = new THREE.IcosahedronBufferGeometry(length * 2, 3);
			var material = new THREE.MeshPhongMaterial({ color: 0x156289, emissive: 0x072534, flatShading: true });
			var mesh = new THREE.Mesh(geometry, material);
			geometry.computeBoundingBox();
			sceneBox.union(geometry.boundingBox.clone().applyMatrix4(mesh.matrix));
			group.add(mesh);

			// simplify geometry
			let boxgroup = new THREE.Group();
			var simplifyBtn = document.getElementById("simplify");
			simplifyBtn.onclick = function () {
				var simplifyTool = new GeometrySimplifyUtil();
				var segments = parseInt(document.getElementById("segments").value);
				var newGeom = simplifyTool.simplify(geometry, { segments: segments });
				
				// console.log("boxlist.length", simplifyTool.boxlist.length)
				boxgroup.children.length = 0;
				simplifyTool.boxlist.forEach((box, index) => {
					boxgroup.add(new THREE.Box3Helper(box, 0xffff00));
				});
				boxgroup.visible = false;
				scene.add(boxgroup);

				mesh = new THREE.Mesh(newGeom, material);
				group.children[0] = mesh;
				sceneBox = new THREE.Box3();
				sceneBox.union(newGeom.boundingBox.clone().applyMatrix4(mesh.matrix));
			}

			//


			// Export button function
			var exportBtn = document.getElementById("export");
			exportBtn.onclick = function () {
				var exporter = new OBJExporter();
				var result = exporter.parse(group);
				result = result.replace(/o \n/g, '');

				var MIME_TYPE = 'text/plain';
				window.URL = window.webkitURL || window.URL;

				var bb = new Blob([result], { type: MIME_TYPE });
				var a = document.createElement('a');
				a.download = 'export.obj';
				a.href = window.URL.createObjectURL(bb);
				a.textContent = 'Download ready';
				a.dataset.downloadurl = [MIME_TYPE, a.download, a.href].join(':');
				a.click();
			}

			//
			var showGrids = document.getElementById("grids");
			showGrids.onclick = function () {
				boxgroup.visible = !boxgroup.visible;
			}
			//

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

			scene.add(group);

			controls = new OrbitControls(camera, renderer.domElement);

			var size = new THREE.Vector3();
			sceneBox.getSize(size);
			var diameter = Math.max(size.x, size.y, size.z);
			camera.position.set(diameter, diameter, diameter);
			camera.lookAt(0, 0, 0);

			document.addEventListener('mousemove', onDocumentMouseMove, false);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function onDocumentMouseMove(event) {

			mouseX = (event.clientX - windowHalfX) / 2;
			mouseY = (event.clientY - windowHalfY) / 2;

		}

		//

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			renderer.render(scene, camera);

		}

	</script>

</body>

</html>